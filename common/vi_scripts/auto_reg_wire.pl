#!/usr/bin/perl -w
use strict;

# debug output turned off by default
my $debug = 0;

# name of this script
my $script_base_name = "auto_wire_reg";
my $script_name = $script_base_name . ".pl";
my $revision = 0.5;

my $usage_string = "USAGE: $script_name infile.v outfile.v";

if (!defined($ARGV[1])) {
    die $usage_string;
}

my $infile;
my $outfile;

$infile = $ARGV[0];
$outfile = $ARGV[1];

my $infile_dirname = substr (`cd \`dirname $infile\`; /bin/pwd`, 0, -1);
my $infile_basename = substr (`basename $infile`, 0, -1);

# create output directory if it does not exist
if ($outfile =~ m|^(.*)/[^/]*$|) {
    my $outdir = $1;
    if (!(-d $outdir)) {
	system ("mkdir -p $outdir");
    }
}

open (OUT, ">$outfile") || die "ERROR: could not open $outfile";

print OUT "// This file is auto generated by $script_name - revision $revision\n";
print OUT "// Input file: $infile_dirname/$infile_basename\n";
print OUT "// Do not modify this file because it will be overwritten when it is auto generated again.\n";

# define some basic regexp blocks
#my $re_range = qw(\[\s*\`?[\w\-\+]+\s*:\s*\`?[\w\-\+]+\s*\]); # match [5:0] or [`DEFHI:`DEFLO]
my $re_range = qw(\[[^\[\]]+:[^\[\]]+\]);
my $re_sig_name = qw([A-Za-z]\w*);


my %wires;
my %regs;
my $line_num = 0;
my @module_ios;
my %module_io_output;

open(IN, $infile) || die "ERROR: could not open $infile";

while (my $line = <IN>) {
    $line_num++;
    my $line_no_newline = $line;
    chop $line_no_newline;

    # get ignore signals
    # form: "// auto_wire_reg ignore signal_name"
    if ($line =~ m/^\s*\/\/\s*$script_base_name\s*ignore\s*(\w+)\s*$/) {
	debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: ignoring wire/reg: $1\n");
	$wires{$1} = 1;
	$regs{$1} = 1;
    }

    # remove comments
    # form: "// blah"
    $line =~ s|\/\/.*$||;

    # get wire declaration
    # form: "wire wire_name"
    #       "wire [2:0] wire_name"
    if ($line =~ m/^\s*wire\s*($re_range)?\s*($re_sig_name)\W/) {
	debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected wire declaration: $2\n");
	$wires{$2} = 1;
    }

    # get io wire declaration
    #       "output wire wire_name"
    #       "output wire [2:0] wire_name"
    #       "output wire_name"
    #       "output [2:0] wire_name"
    #       OR (seperate regexp)
    #       "input wire wire_name"
    #       "input wire [2:0] wire_name"
    #       "input wire_name"
    #       "input [2:0] wire_name"
    #       OR (seperate regexp)
    #       "inout wire wire_name"
    #       "inout wire [2:0] wire_name"
    #       "inout wire_name"
    #       "inout [2:0] wire_name"
    if (($line =~ m/^\s*output\s*(wire)?\s*($re_range)?\s*($re_sig_name)\W/) ||
	($line =~ m/^\s*input\s*(wire)?\s*($re_range)?\s*($re_sig_name)\W/) ||
	($line =~ m/^\s*inout\s*(wire)?\s*($re_range)?\s*($re_sig_name)\W/)) {
	debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected wire declaration: $3\n");
	$wires{$3} = 1;
    }

    # get reg declaration
    # form: "reg reg_name"
    #       "output reg reg_name"
    #       "reg [2:0] reg_name"
    #       "output reg [2:0] reg_name"
    if ($line =~ m/^\s*(output)?\s*reg\s*($re_range)?\s*($re_sig_name)\W/) {
	debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected reg declaration: $3\n");
	$regs{$3} = 1;
    }

    # get integer declaration
    # we handle integers as regs
    # form: "integer reg_name"
    if ($line =~ m/^\s*integer\s*($re_sig_name)\W/) {
	debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected integer (reg) declaration: $1\n");
	$regs{$1} = 1;
    }

    # get real declaration
    # we handle reals as regs
    # form: "real reg_name"
    if ($line =~ m/^\s*real\s*($re_sig_name)\W/) {
	debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected real (reg) declaration: $1\n");
	$regs{$1} = 1;
    }

    # get parameter declaration
    # we handle parameters as regs
    # form: "parameter reg_name"
    if ($line =~ m/^\s*parameter\s*($re_sig_name)\W/) {
	debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected parameter (reg) declaration: $1\n");
	$regs{$1} = 1;
    }

    if ($line =~ m/^\s*tri\s*($re_sig_name)\W/) {
	debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected parameter (reg) declaration: $1\n");
	$regs{$1} = 1;
    }

    if ($line =~ m/^\s*tri1\s*($re_sig_name)\W/) {
	debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected parameter (reg) declaration: $1\n");
	$regs{$1} = 1;
    }

    if ($line =~ m/^\s*localparam\s*($re_sig_name)\W/) {
	debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected parameter (reg) declaration: $1\n");
	$regs{$1} = 1;
    }

    if ($line =~ m/^\s*genvar\s*($re_sig_name)\W/) {
	debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected parameter (reg) declaration: $1\n");
	$regs{$1} = 1;
    }

    # detect wire assignment
    # form: "assign wire_name ="
    #       "assign wire_name[2:0] ="
    if ($line =~ m/^\s*assign\s*($re_sig_name)\s*($re_range)?\s*=/) {
	my $new_wire = $1;
	my $new_wire_width = defined($2) ? $2 : "";
	if (!$wires{$new_wire} && !$regs{$new_wire}) {
	    debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected new wire: $new_wire$new_wire_width\n");
	    printf OUT ("%-4s %-30s %-30s %s\n", "wire", "$new_wire_width", "$new_wire;", "// from $infile_basename:$line_num: $line_no_newline");
	    $wires{$new_wire} = 1;
	} else {
	    debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected wire previously declared: $new_wire$new_wire_width\n");
	}
    } else {

    # detect reg assignment
    # form: "reg_name ="
    #       "reg_name[2:0] ="
	if ($line =~ m/^(.*\W)?($re_sig_name)\s*($re_range)?\s*<?=[^=]/) {
	    my $new_reg = $2;
	    my $new_reg_width = defined ($3) ? $3 : "";
	    if (!$regs{$new_reg} && !$wires{$new_reg}) {
		debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected new reg: $new_reg$new_reg_width\n");
		printf OUT ("%-4s %-30s %-30s %s\n", "reg", "$new_reg_width", "$new_reg;", "// from $infile_basename:$line_num: $line_no_newline");
		$regs{$new_reg} = 1;
	    } else {
		debugout ("// $infile_basename:$line_num: $line_no_newline // $script_name: detected reg previously declared: $new_reg$new_reg_width\n");
	    }
	}
    }
    
    # detect module IOs
    # form: .ioname (wirename)
    #       .ioname (wirename[2:0])
    my $module_params_line = $line;
    while ($module_params_line =~ s/(\.(\w+)\s*\(\s*($re_sig_name)\s*($re_range)?\s*\))//) {
	my $io_decl_string = $1;
	my $module_sig = $2;
	my $new_wire = $3;
	my $new_wire_width = defined($4) ? $4 : "";
	
	push @module_ios, $new_wire;
	$module_io_output{$new_wire} = sprintf ("%-4s %-30s %-30s %s\n", "wire", "$new_wire_width", "$new_wire;", "// from $infile_basename:$line_num: $line_no_newline");
    }
}

# check if the module ios have been declared
# if not, we declare them as wires
foreach my $module_io (@module_ios) {
    if (!$regs{$module_io} && !$wires{$module_io}) {
	print OUT $module_io_output{$module_io};
	$wires{$module_io} = 1;
    }
}


close (IN);
close (OUT);

sub debugout {
    my $output;
    ($output) = @_;
    if ($debug) {
	print $output;
    }
}

